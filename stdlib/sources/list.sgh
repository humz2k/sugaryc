#include <assert.sgh>
#include <stdlib.sgh>

#ifndef list_t
#define list_t int
#endif

#define _COMBINE(a,b) a ## b
#define _combine(a, b) _COMBINE(a, b)

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)

#define list_struct _combine(list_t,_list_struct)
#define list_block _combine(list_t,_list_block)
#define alloc_list_block _combine(alloc_,_combine(list_t,_list_block))
#define index_list_block _combine(index_,_combine(list_t,_list_block))
#define LIST _combine(list_t,_list)
#define make_list _combine(make_,LIST)

#define LIST_BLOCK_SIZE 20

struct list_block{
    list_t item;
    struct list_block* next;
};

struct list_block* alloc_list_block(void){
    struct list_block* out = (struct list_block*)GC_malloc(sizeof(struct list_block));
    out->next = NULL;
    return out;
}

struct list_struct{
    int length;
    struct list_block* first;
};

typedef struct list_struct* LIST;

LIST make_list(void){
    LIST out = (LIST)GC_malloc(sizeof(struct list_struct));
    out->length = 0;
    out->first = NULL;
    return out;
}

static inline struct list_block* index_list_block(struct list_block* block, int idx){
    struct list_block* cur = block;
    if (cur == NULL){
        print("%s bounds error: %d out of bounds\n",TOSTRING(lst),idx);
        exit(1);
    }

    for (int i = 0; i < idx; i++){
        cur = cur->next;
        if (cur == NULL){
            print("%s bounds error: %d out of bounds\n",TOSTRING(lst),idx);
            exit(1);
        }
    }

    return cur;
}

list_t* __index__(LIST lst, int* idx, int nidx){
    assert(nidx == 1);
    assert(lst != NULL);
    struct list_block* block = index_list_block(lst->first,*idx);
    return &block->item;
}

int append(LIST lst, list_t val){
    assert(lst != NULL);
    if (lst->length == 0){
        assert(lst->first == NULL);
        lst->first = alloc_list_block();
        lst->first->item = val;
        lst->length = 1;
        return lst->length;
    }
    assert(lst->length > 0);
    struct list_block* block = index_list_block(lst->first,lst->length - 1);
    assert(block != NULL);
    assert(block->next == NULL);
    block->next = alloc_list_block();
    block->next->item = val;
    lst->length++;
    return lst->length;
    
}

list_t pop(LIST lst, int idx){
    assert(lst != NULL);
    if (lst->length == 0){
        assert(lst->first == NULL);
        print("%s bounds error: trying to pop from empty list\n",TOSTRING(list));
        exit(1);
    }
    
    if (idx == 0){
        struct list_block* block = lst->first;
        lst->first = lst->first->next;
        lst->length--;
        return block->item;
    }
    
    assert(idx > 0);

    struct list_block* block = index_list_block(lst->first,idx-1);

    //FINISH ME

}

#undef list_struct
#undef list_block
#undef alloc_list_block
#undef index_list_block
#undef LIST
#undef make_list